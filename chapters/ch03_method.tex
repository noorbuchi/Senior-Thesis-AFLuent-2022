\chapter{Method of Approach}
\label{ch:method}

This chapter describes the implementation of AFLuent and the experiment setup and
execution process. More specifically, the reasoning behind design decisions and
the result are the main focus. Additionally, charts and diagrams  are used to
demonstrate the the algorithms, structure, and flow of execution.

\section{Development Environment and Toolset}
\label{sec:DevEnviron}

Prior to explain how implementation was completed, a ground-up overview of the
tools used and their roles is necessary to establish definitions and facilitate
the understanding of how dependencies they are connected. AFLuent being a Python
tool allows its development to rely on a wide variety of helpful and popular
tools. Some of the most important tools and dependencies are discussed below.

\subsection{Poetry}
\label{subsec:poetry}

Poetry is a Python virtual environment management tool that allows developers to
set up an isolated environment for their projects. Furthermore, it manges the
installation of Python dependencies on the virtualenv and updates them when
necessary. Poetry has a crucial role in the implementation of AFLuent since it's
used to make the development process simpler, its role also goes beyond
that to the packaging and publishing of AFLuent to the Python Package Index
(PyPI). Poetry's ability to abstract and simplify all the details in creating a
Python package, makes it essential for development. However, from a user's
perspective, Poetry is not necessary to run or use the tool for fault localization.

\subsection{Pytest}
\label{subsec:pytest}

Pytest is a Python testing framework used to write and execute a variety of
tests, especially unit tests. Many developers in the community have contributed
to Pytest through plugins that extend Pytest's functionality and allow it to
accomplish new beneficial tasks. As mentioned previously, AFLuent is a Pytest
plugin that adds automated fault localization features. By definition, AFLuent
relies on Pytest in order to function properly. More details on how AFLuet is
integrated with pytest can be found in Section \ref{sec:makingPytestPlugin}.

\subsection{Coverage.py}
\label{subsec:coverage}

Spectrum based fault localization requires data on code coverage and test
results in order to calculate and rank suspicious of elements in the code.
Coverage.py\cite{coverage_py_website} is a Python tool that provides an easy to use application
programming interface to collect that data. The tool also provides various
configuration for the user to skip certain file or directories from being
considered. AFLuent relies on this tool to calculate what's known as per-test
coverage. This data describes the lines of code covered by a single test case
and organized in an accessible way to find out the number of passing and failing
test cases that executed each line. Automated fault localization approaches
require this information in order to calculate suspiciousness scores and
Coverage.py can provide that relatively easily.

\subsection{Radon}
\label{subsec:radon}

% TODO: not sure if this will be kept in
Radon is a Python tool used to calculate metrics of code complexity.
Specifically, it's used in AFLuent to calculate cyclomatic complexity of some
elements to break ties in rankings.

\subsection{Libcst}
\label{subsec:libcst}

\emph{TODO: will be discussed further after implementation}

% TODO: should a subsection on AFLuent installation be added here?

\section{AFLuent as a Pytest Plugin}
\label{sec:makingPytestPlugin}

\begin{figure}[!htb]
	\begin{center}
		\includegraphics[width=11.9cm]{pytest_flowfchart.png}
		\caption{\label{fig:pytest_flow} Pytest Tasks Flowchart}
	\end{center}
\end{figure}

Pytest provides simple and intuitive ways of extending its functionality through
hooks. These hooks break up the standard Pytest execution steps and allow
external code to run at these points. A plugin is essentially a collection of
packaged hooks that fit in the workflow of Pytest. AFLuent makes use of five
different hooks to implement automated fault localization.
Fig.\ref{fig:pytest_flow} shows a general overview of the steps changed in the
workflow of Pytest. Additionally, the section below describes in details how each
step was modified.

\subsection{Adding Command-Line Arguments}
\label{subsec:pytest_cli}

Pytest already supports a multitude of command line arguments that allow the
user to pass configuration that change how the test suite is executed and
reported. Similarly, AFLuent requires user passed arguments to complete a
variety of tasks. The hook \code{pytest\_addoption} allows adding new
arguments in a fashion similar to the \code{argparse} Python library.
The \code{argparse} library supports features that allow easy parsing and validation of
command-line arguments. Furthermore, it facilitates working with input with
various data types.
The added arguments accept values that specify the following:
\begin{itemize}
    \item If AFLuent should be enabled for the current Pytest session.
    \begin{itemize}
        \item Flags: \code{---afl-debug} or \code{---afl}
    \end{itemize}
    \item The techniques for suspiciousness score calculations
%    TODO: add approaches to the list after implementation
    \begin{itemize}
        \item \code{---tarantula}: enable fault localization using Tarantula approach
        \item \code{---ochiai}: enable fault localization using Ochiai approach
        \item \code{---dstar}: enable fault localization using DStar approach
        \item \code{---dstar-pow}: used to set the power to use in the DStar
        approach. Defaults to 3
        \item Multiple approaches can be used at the same time, however, results
        will be sorted by the approach passed first.
    \end{itemize}
    \item The number of results to display in the report
    \begin{itemize}
        \item \code{---afl-results}: number of top results to show in the
        terminal window. Defaults to 20
    \end{itemize}
    \item The directories and files to be ignored while calculating coverage
    \begin{itemize}
        \item \code{---afl-ignore}: Used to pass directories and files to
        ignore. Example: \code{tests/*} will ignore all files and directories
        inside the \code{tests} folder.
    \end{itemize}
    \item The types of file reports to created after the Pytest session is over
    \begin{itemize}
        \item \code{---report}: accepts \code{json} or \code{csv} and generate
        reports with the passed format.
        \item \code{---per-test-report}: requires that a per-test coverage
        report is produced. This report is only generated in JSON format.
    \end{itemize}
    \item If complexity metrics should be used in breaking ties of ranked elements
    \begin{itemize}
        \item \code{---cyclomatic-complexity}: use cyclomatic complexity metrics
        in breaking ties found in suspiciousness scores
        \item \code{---syntax-complexity}: use syntax complexity metrics
        in breaking ties found in suspiciousness scores
    \end{itemize}
\end{itemize}

\subsection{Activating AFLuent}
\label{subsec:activate_afluent}

After arguments are passed, the next steps parses through some of them to check
if AFLuent was enabled and to validate some of their values. The Pytest hook
\code{pytest\_cmdline\_main} gives access to the collected configuration. In
this hook, checks are conducted to see if there are other active plugins that
utilize Coverage.py. These checks are necessary due to conflicts in collecting
data when multiple plugins use Coverage.py simultaneously. The problem is
resolved through warnings to the user that ask to disable these plugins in order
for AFLuent to run properly. Lastly, if AFLuent is enabled, an \code{Afluent} object is initialized
with the passed configuration and registered as a plugin for the current Pytest session.

\subsection{Calculating Per-test Coverage and Test Result}
\label{subsec:calculate_coverage}

Per-test coverage is defined here as the collection of lines executed by
each individual test case. In order to collect this data, AFLuent adds a wrapper
that executes code before and after each test case function is called. The
\code{pytest\_pyfunc\_call} hook is used in this scenario. The execution steps
are as follows:

\begin{enumerate}
    \item \code{cov.start()} begins recording coverage
    \item the hook yields back control to Pytest which calls the individual test case
    \item \code{cov.stop()} stops recording coverage
    \item The collected data is then organized in a simpler structure defined as
    the program specta
    \item The process repeats for every test case
\end{enumerate}

Once per-test coverage is completed, the \code{pytest\_runtest\_makereport} hook
is used to get the outcome of each test case and add it to the program spectra
structure. There are three possible test outcome in Pytest, `Passed', `Failed',
and `Skipped'.

\subsection{Reporting Results}
\label{subsec:report_results}

The last step in AFLuent execution as part of Pytest is to report the fault
localization outcome. The \code{pytest\_sessionfinish} hook is used to detect the
exit code of the session and display output on the console accordingly. An exist
code of 0 means that all tests have passed and there is no need to perform fault
localization, therefore, a message would display that to the user before
finishing the Pytest run. On the other hand an exit code of 1, would indicate
that at least one test case failed during the pytest session. In this scenario,
AFLuent initializes a \code{Spectrum} object, which is responsible for parsing
through the program spectra structure, ranking elements based on suspiciousness,
and producing an output to the console.

% TODO: add example of AFLuent output here

\section{AFLuent's Components}
\label{sec:components}

Considering all the steps involved in calculating and reporting suspiciousness
of elements, AFLuent is implemented in an object oriented style that focuses on
the readability and maintainability of the code. By splitting up AFLuent to a
collection of objects organized in a hierarchy, the testing approach becomes more
clear and debugging becomes easier. This section discusses the objects oriented
structure starting with the least complex.

\subsection{Line Object}
\label{subsec:line_obj}

A line is the simplest unit in a large project or program. With that in mind, a
\code{Line} object describes the attributes and implements the functionalities
associated with a single line in the context of automated fault localization.
Important attributes of a line include identifiers such as the line number and
file path it belongs to. Other line-specific information include a list of
failed test cases that executed this line, and another for tests that passed.
This information is crucial in calculating the one of the main focuses of
AFLuent, which is suspiciousness scores. These scores are also stored as
attributes of each Line object. Another stored attribute is complexity,
which is a metric associated with each line and used to break ties in rankings.
Further reading on complexity metrics can be found in REFERENCE TO BE DETERMINED
% TODO: requires elaboration

As for functions, a Line object contains an implementation of the three
equations, Tarantula shown in Fig.\ref{fig:tarantulaEquation}, Ochiai shown in
Fig.\ref{fig:ochiaiEquation}, and DStar shown in Fig.\ref{fig:dstarEquation},
where suspiciousness scores are calculated and rounded up to four decimal places.
The mathematical implementations of these functions also handle and account for
division by zero. Depending on the equation, there could be multiple instances
where division by zero is possible. The following subsections discuss how this
issue was handled for each equation.

% TODO: the number of equations should be updated once new ones are added

% TODO: provide example figures
\subsubsection{Division by Zero: Tarantula}
\label{subsubsec:div_by_zero_taran}
In the Tarantula equation, division by zero occurs if either the number of
total passing tests or number of total failing tests is zero. In the case that
there are no failing test-cases in the whole test suite, then the suspiciousness
of all covered statements is zero (not suspicious) since there was no fault. The
other edge case occurs when there are no passing tests in the whole test suite,
in which every covered line has the maximum suspiciousness of 1. It is important
to acknowledge that the outcomes reached here only apply to code that has been
covered by the test suite. Faulty lines, which are not covered by any test case
will not be investigated since there is no data to calculate their suspiciousness.

\subsubsection{Division by Zero: Ochiai}
\label{subsubsec:div_by_zero_ochiai}

Division by zero occurs in the Ochiai formula when the number of failed tests
that cover the line is zero or when the total number of failed tests is zero.
Both of these cases indicate that the line is not suspicious since it did not
cause any failures, therefore, zero is returned as the suspiciousness score.

\subsubsection{Division by Zero: DStar}
\label{subsubsec:div_by_zero_dstar}

In the DStar equation, division by zero takes place only in one case. When the
number of passing test cases that cover the line AND the number of failed test
cases that do not cover the line are both zero, the denominator evaluates to
zero. This translates to the following: if there is no passing tests executing
this line and no failing test executing other lines only, then this line should
have the maximum suspiciousness score possible. However, since DStar has a
numerator raised to a power set by the user, it has no numerical upper limit on
the resulting score. To resolve this issue, the maximum integer value is
assigned as the suspiciousness score of this line.

\subsection{ProjFile Object}
\label{subsec:projfile_obj}

ProjFile objects are designed to contain attributes that describe whole files.
Additionally, they support functionality that apply to these files. The most
important attributes of these objects is the \code{lines} instance variable,
which stores a dictionary of contents of the file. Specifically, the keys in
this dictionary are line numbers in the file and the values are the Line objects
discussed previously. In addition to storing this data, ProjFile implements an
intuitive way to update it with a new result of a test case. \code{update\_file}
function takes in a list of numbers of covered lines executed by a test case as well as the
result and the name of that test case. Following that, it iterates through the
covered line numbers and updates the Line objects stored in the ProjFile
dictionary. This approach creates a hierarchy between the objects by nesting
Line objects inside of ProjFile objects.

\subsection{Spectrum Object}
\label{subsec:spectrum_obj}

This object contains some of the core functionalities that organizes the
collected data and displays it to the console. Similar to how a ProjFile object
stores a dictionary of line number and Line object pairs, Spectrum takes nesting
a step further and stores a dictionary of file paths and ProjFile objects as
key-value pairs. Additionally, it keeps track of running totals of passed,
failed, and skipped test cases, which are used to calculate suspiciousness
scores. Lastly, it's responsible for sorting Line objects in a descending order
from highest suspiciousness scores. Once this task is completed, the Spectrum
object produces a table formatted report with color coded results that
demonstrate to the user the outcome of fault localization.
% TODO: discuss more about the report structure and colors and give figure example

\subsection{Afluent Object}
\label{subsec:afluent_obj}

While this Object does not implement any functionality regarding the calculation
or sorting of suspiciousness scores, it plays an important role in integrating
this tool with Pytest. By containing several of the Pytest hooks mentioned
prior, this object is registered as the plugin when AFLuent is enabled through
command line arguments. Following the end of the Pytest session, the AFluent
object initializes a Spectrum Object and forwards the arguments collected from
the console command. Following that, it calls the Spectrum object to produce and
print its report. Overall, this object acts as a pipeline that passes coverage
information and command line arguments collected from the Pytest session to the
infrastructure responsible for performing fault localization.

\subsection{Objects Overview}
\label{subsec:obj_overview}

\begin{figure}[!htb]
	\begin{center}
		\includegraphics[width=15.5cm]{object_oriented_structure.png}
		\caption{\label{fig:oop_structure} AFLuent Object Structure}
	\end{center}
\end{figure}

Fig\ref{fig:oop_structure} provides a visual simplification of the different
components of AFluent and an overview of their roles in the functioning of the
tool. Overall the nested structure creates several layers that facilitate
development by isolating the different components and hiding unnecessary
information from other objects in the hierarchy.